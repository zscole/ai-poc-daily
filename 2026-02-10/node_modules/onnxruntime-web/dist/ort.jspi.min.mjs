/*!
 * ONNX Runtime Web v1.25.0-dev.20260209-a3749f1353
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var rt=Object.defineProperty;var Jr=Object.getOwnPropertyDescriptor;var Yr=Object.getOwnPropertyNames;var qr=Object.prototype.hasOwnProperty;var nt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var T=(t,e)=>()=>(t&&(e=t(t=0)),e);var Ae=(t,e)=>{for(var r in e)rt(t,r,{get:e[r],enumerable:!0})},Xr=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Yr(e))!qr.call(t,n)&&n!==r&&rt(t,n,{get:()=>e[n],enumerable:!(o=Jr(e,n))||o.enumerable});return t};var ot=t=>Xr(rt({},"__esModule",{value:!0}),t);var ve,re,ne,Zr,xt,st=T(()=>{"use strict";ve=new Map,re=[],ne=(t,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=ve.get(t);if(o===void 0)ve.set(t,{backend:e,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${r}`)}if(r>=0){let n=re.indexOf(t);n!==-1&&re.splice(n,1);for(let s=0;s<re.length;s++)if(ve.get(re[s]).priority<=r){re.splice(s,0,t);return}re.push(t)}return}throw new TypeError("not a valid backend")},Zr=async t=>{let e=ve.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let r=!!e.initPromise;try{return r||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return r||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},xt=async t=>{let e=t.executionProviders||[],r=e.map(u=>typeof u=="string"?u:u.name),o=r.length===0?re:r,n,s=[],a=new Set;for(let u of o){let f=await Zr(u);typeof f=="string"?s.push({name:u,err:f}):(n||(n=f),n===f&&a.add(u))}if(!n)throw new Error(`no available backend found. ERR: ${s.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:f}of s)r.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${f}`);let i=e.filter(u=>a.has(typeof u=="string"?u:u.name));return[n,new Proxy(t,{get:(u,f)=>f==="executionProviders"?i:Reflect.get(u,f)})]}});var Bt=T(()=>{"use strict";st()});var Ot,Ut=T(()=>{"use strict";Ot="1.24.0-dev.20251116-b39e144322"});var Dt,U,at=T(()=>{"use strict";Ut();Dt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:Ot},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Dt=t}},get logLevel(){return Dt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var v,Ct=T(()=>{"use strict";at();v=U});var Pt,_t,Rt=T(()=>{"use strict";Pt=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=t.dims[3],r.height=t.dims[2];let o=r.getContext("2d");if(o!=null){let n,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],s=t.dims[3]):(n=t.dims[3],s=t.dims[2]);let a=e?.format!==void 0?e.format:"RGB",i=e?.norm,u,f;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean=="number"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?f=[0,0,0,0]:typeof i.bias=="number"?f=[i.bias,i.bias,i.bias,i.bias]:(f=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(f[3]=i.bias[3]));let c=s*n,d=0,p=c,l=c*2,h=-1;a==="RGBA"?(d=0,p=c,l=c*2,h=c*3):a==="RGB"?(d=0,p=c,l=c*2):a==="RBG"&&(d=0,l=c,p=c*2);for(let w=0;w<s;w++)for(let L=0;L<n;L++){let y=(t.data[d++]-f[0])*u[0],m=(t.data[p++]-f[1])*u[1],A=(t.data[l++]-f[2])*u[2],b=h===-1?255:(t.data[h++]-f[3])*u[3];o.fillStyle="rgba("+y+","+m+","+A+","+b+")",o.fillRect(L,w,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},_t=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(r!=null){let n,s,a;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],s=t.dims[1],a=t.dims[3]):(n=t.dims[3],s=t.dims[2],a=t.dims[1]);let i=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,f,c;u===void 0||u.mean===void 0?f=[255,255,255,255]:typeof u.mean=="number"?f=[u.mean,u.mean,u.mean,u.mean]:(f=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(f[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias=="number"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let d=s*n;if(e!==void 0&&(e.format!==void 0&&a===4&&e.format!=="RGBA"||a===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let p=4,l=0,h=1,w=2,L=3,y=0,m=d,A=d*2,b=-1;i==="RGBA"?(y=0,m=d,A=d*2,b=d*3):i==="RGB"?(y=0,m=d,A=d*2):i==="RBG"&&(y=0,A=d,m=d*2),o=r.createImageData(n,s);for(let I=0;I<s*n;l+=p,h+=p,w+=p,L+=p,I++)o.data[l]=(t.data[y++]-c[0])*f[0],o.data[h]=(t.data[m++]-c[1])*f[1],o.data[w]=(t.data[A++]-c[2])*f[2],o.data[L]=b===-1?255:(t.data[b++]-c[3])*f[3]}else throw new Error("Can not access image data");return o}});var it,Nt,Ft,Wt,kt,Gt,$t=T(()=>{"use strict";Me();it=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=e,n=e.norm??{mean:255,bias:0},s,a;typeof n.mean=="number"?s=[n.mean,n.mean,n.mean,n.mean]:s=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?a=[n.bias,n.bias,n.bias,n.bias]:a=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let i=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",f=r*o,c=u==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),d=4,p=0,l=1,h=2,w=3,L=0,y=f,m=f*2,A=-1;i==="RGB"&&(d=3,p=0,l=1,h=2,w=-1),u==="RGBA"?A=f*3:u==="RBG"?(L=0,m=f,y=f*2):u==="BGR"&&(m=0,y=f,L=f*2);for(let I=0;I<f;I++,p+=d,h+=d,l+=d,w+=d)c[L++]=(t[p]+a[0])/s[0],c[y++]=(t[l]+a[1])/s[1],c[m++]=(t[h]+a[2])/s[2],A!==-1&&w!==-1&&(c[A++]=(t[w]+a[3])/s[3]);return u==="RGBA"?new _("float32",c,[1,4,r,o]):new _("float32",c,[1,3,r,o])},Nt=async(t,e)=>{let r=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,n=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,s=typeof t=="string",a,i=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(r){let c=u();c.width=t.width,c.height=t.height;let d=f(c);if(d!=null){let p=t.height,l=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(p=e.resizedHeight,l=e.resizedWidth),e!==void 0){if(i=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=p,i.width=l}else i.tensorFormat="RGBA",i.height=p,i.width=l;d.drawImage(t,0,0),a=d.getImageData(0,0,l,p).data}else throw new Error("Can not access image data")}else if(o){let c,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,d=e.resizedWidth):(c=t.height,d=t.width),e!==void 0&&(i=e),i.format="RGBA",i.height=c,i.width=d,e!==void 0){let p=u();p.width=d,p.height=c;let l=f(p);if(l!=null)l.putImageData(t,0,0),a=l.getImageData(0,0,d,c).data;else throw new Error("Can not access image data")}else a=t.data}else if(n){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=u();c.width=t.width,c.height=t.height;let d=f(c);if(d!=null){let p=t.height,l=t.width;return d.drawImage(t,0,0,l,p),a=d.getImageData(0,0,l,p).data,i.height=p,i.width=l,it(a,i)}else throw new Error("Can not access image data")}else{if(s)return new Promise((c,d)=>{let p=u(),l=f(p);if(!t||!l)return d();let h=new Image;h.crossOrigin="Anonymous",h.src=t,h.onload=()=>{p.width=h.width,p.height=h.height,l.drawImage(h,0,0,p.width,p.height);let w=l.getImageData(0,0,p.width,p.height);i.height=p.height,i.width=p.width,c(it(w.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return it(a,i);throw new Error("Input data provided is not supported - aborted tensor creation")},Ft=(t,e)=>{let{width:r,height:o,download:n,dispose:s}=e,a=[1,o,r,4];return new _({location:"texture",type:"float32",texture:t,dims:a,download:n,dispose:s})},Wt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:s}=e;return new _({location:"gpu-buffer",type:r??"float32",gpuBuffer:t,dims:o,download:n,dispose:s})},kt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:s}=e;return new _({location:"ml-tensor",type:r??"float32",mlTensor:t,dims:o,download:n,dispose:s})},Gt=(t,e,r)=>new _({location:"cpu-pinned",type:t,data:e,dims:r??[e.length]})});var oe,we,zt,Vt,jt=T(()=>{"use strict";oe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),we=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),zt=!1,Vt=()=>{if(!zt){zt=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,o=typeof r<"u"&&r.from;t&&(oe.set("int64",BigInt64Array),we.set(BigInt64Array,"int64")),e&&(oe.set("uint64",BigUint64Array),we.set(BigUint64Array,"uint64")),o?(oe.set("float16",r),we.set(r,"float16")):oe.set("float16",Uint16Array)}}});var Ht,Jt,Yt=T(()=>{"use strict";Me();Ht=t=>{let e=1;for(let r=0;r<t.length;r++){let o=t[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);e*=o}return e},Jt=(t,e)=>{switch(t.location){case"cpu":return new _(t.type,t.data,e);case"cpu-pinned":return new _({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new _({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new _({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new _({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var _,Me=T(()=>{"use strict";Rt();$t();jt();Yt();_=class{constructor(e,r,o){Vt();let n,s;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,s=e.dims,e.location){case"cpu-pinned":{let i=oe.get(n);if(!i)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint64"&&n!=="int8"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof e=="string")if(n=e,u=o,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");i=r}else{let f=oe.get(e);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&f===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${f.name} as data.`);e==="uint64"||e==="int64"?i=f.from(r,BigInt):i=f.from(r)}else if(r instanceof f)i=r;else if(r instanceof Uint8ClampedArray)if(e==="uint8")i=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&r instanceof Uint16Array&&f!==Uint16Array)i=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw new TypeError(`A ${n} tensor's data must be type of ${f}`)}else if(u=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof e[0];if(f==="string")n="string",i=e;else if(f==="boolean")n="bool",i=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",i=Uint8Array.from(e);else{let f=we.get(e.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=f,i=e}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");s=u,this.cpuData=i,this.dataLocation="cpu"}let a=Ht(s);if(this.cpuData&&a!==this.cpuData.length&&!((n==="uint4"||n==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=a}static async fromImage(e,r){return Nt(e,r)}static fromTexture(e,r){return Ft(e,r)}static fromGpuBuffer(e,r){return Wt(e,r)}static fromMLTensor(e,r){return kt(e,r)}static fromPinnedBuffer(e,r,o){return Gt(e,r,o)}toDataURL(e){return Pt(this,e)}toImageData(e){return _t(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Jt(this,e)}}});var V,ut=T(()=>{"use strict";Me();V=_});var qt,Xt,se,ae,Z,K,ft=T(()=>{"use strict";at();qt=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Xt=(t,e)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${t}::${r[n].trim().split(" ")[1]}`;e&&(s+=`::${e}`),qt("CPU",s);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},se=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Xt("BEGIN",t)},ae=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Xt("END",t)},Z=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.time(`ORT::${t}`)},K=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeEnd(`ORT::${t}`)}});var xe,Zt=T(()=>{"use strict";st();ut();ft();xe=class t{constructor(e){this.handler=e}async run(e,r,o){se(),Z("InferenceSession.run");let n={},s={};if(typeof e!="object"||e===null||e instanceof V||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof V)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let f of r){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);n[f]=null}if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,c=Object.getOwnPropertyNames(r);for(let d of this.outputNames)if(c.indexOf(d)!==-1){let p=r[d];(p===null||p instanceof V)&&(f=!0,a=!1,n[d]=p)}if(f){if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof e[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(a)for(let f of this.outputNames)n[f]=null;let i=await this.handler.run(e,n,s),u={};for(let f in i)if(Object.hasOwnProperty.call(i,f)){let c=i[f];c instanceof V?u[f]=c:u[f]=new V(c.type,c.data,c.dims)}return K("InferenceSession.run"),ae(),u}async release(){return this.handler.dispose()}static async create(e,r,o,n){se(),Z("InferenceSession.create");let s,a={};if(typeof e=="string"){if(s=e,typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(s=e,typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,d=0,p=e.byteLength;if(typeof r=="object"&&r!==null)a=r;else if(typeof r=="number"){if(d=r,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(p=e.byteLength-d,typeof o=="number"){if(p=o,!Number.isSafeInteger(p))throw new RangeError("'byteLength' must be an integer.");if(p<=0||d+p>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-d}].`);if(typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(c,d,p)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,u]=await xt(a),f=await i.createInferenceSessionHandler(s,u);return K("InferenceSession.create"),ae(),new t(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}});var Kr,Kt=T(()=>{"use strict";Zt();Kr=xe});var Qt=T(()=>{"use strict"});var er=T(()=>{"use strict"});var tr=T(()=>{"use strict"});var rr=T(()=>{"use strict"});var ct={};Ae(ct,{InferenceSession:()=>Kr,TRACE:()=>qt,TRACE_EVENT_BEGIN:()=>Z,TRACE_EVENT_END:()=>K,TRACE_FUNC_BEGIN:()=>se,TRACE_FUNC_END:()=>ae,Tensor:()=>V,env:()=>v,registerBackend:()=>ne});var Q=T(()=>{"use strict";Bt();Ct();Kt();ut();Qt();er();ft();tr();rr()});var Be=T(()=>{"use strict"});var ar={};Ae(ar,{default:()=>Qr});var or,sr,Qr,ir=T(()=>{"use strict";dt();ee();Oe();or="ort-wasm-proxy-worker",sr=globalThis.self?.name===or;sr&&(self.onmessage=t=>{let{type:e,in:r}=t.data;try{switch(e){case"init-wasm":Ue(r.wasm).then(()=>{De(r).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;Ce(n,o).then(()=>{postMessage({type:e})},s=>{postMessage({type:e,err:s})});break}case"copy-from":{let{buffer:o}=r,n=ge(o);postMessage({type:e,out:n});break}case"create":{let{model:o,options:n}=r;Pe(o,n).then(s=>{postMessage({type:e,out:s})},s=>{postMessage({type:e,err:s})});break}case"release":_e(r),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:n,inputs:s,outputIndices:a,options:i}=r;Re(o,n,s,a,new Array(a.length).fill(null),i).then(u=>{u.some(f=>f[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:u},Fe([...s,...u]))},u=>{postMessage({type:e,err:u})});break}case"end-profiling":Ne(r),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Qr=sr?null:t=>new Worker(t??G,{type:"module",name:or})});var cr,en,tn,G,We,pt,rn,nn,dr,on,ur,pr,fr,lr,Oe=T(()=>{"use strict";Be();cr=typeof location>"u"?void 0:location.origin,en=import.meta.url>"file:"&&import.meta.url<"file;",tn=()=>{if(!!1){if(en){let t=URL;return new URL(new t("ort.jspi.min.mjs",import.meta.url).href,cr).href}return import.meta.url}},G=tn(),We=()=>{if(G&&!G.startsWith("blob:"))return G.substring(0,G.lastIndexOf("/")+1)},pt=(t,e)=>{try{let r=e??G;return(r?new URL(t,r):new URL(t)).origin===cr}catch{return!1}},rn=(t,e)=>{let r=e??G;try{return(r?new URL(t,r):new URL(t)).href}catch{return}},nn=(t,e)=>`${e??"./"}${t}`,dr=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},on=async t=>(await import(/*webpackIgnore:true*/ /*@vite-ignore*/t)).default,ur=(ir(),ot(ar)).default,pr=async()=>{if(!G)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(pt(G))return[void 0,ur()];let t=await dr(G);return[t,ur(t)]},fr=void 0,lr=async(t,e,r,o)=>{let n=fr&&!(t||e);if(n)if(G)n=pt(G);else if(o&&!r)n=!0;else throw new Error("cannot determine the script source URL.");if(n)return[void 0,fr];{let s="ort-wasm-simd-threaded.jspi.mjs",a=t??rn(s,e),i=!!1&&r&&a&&!pt(a,e),u=i?await dr(a):a??nn(s,e);return[i?u:void 0,await on(u)]}}});var lt,mt,ke,mr,sn,an,un,Ue,S,ee=T(()=>{"use strict";Oe();mt=!1,ke=!1,mr=!1,sn=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},an=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},un=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Ue=async t=>{if(mt)return Promise.resolve();if(ke)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(mr)throw new Error("previous call to 'initializeWebAssembly()' failed.");ke=!0;let e=t.initTimeout,r=t.numThreads;if(t.simd!==!1){if(t.simd==="relaxed"){if(!un())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!an())throw new Error("WebAssembly SIMD is not supported in the current environment.")}if(!("Suspending"in WebAssembly))throw new Error("WebAssembly JSPI is not supported in the current environment.");let o=sn();r>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=r=1);let n=t.wasmPaths,s=typeof n=="string"?n:void 0,a=n?.mjs,i=a?.href??a,u=n?.wasm,f=u?.href??u,c=t.wasmBinary,[d,p]=await lr(i,s,r>1,!!c||!!f),l=!1,h=[];if(e>0&&h.push(new Promise(w=>{setTimeout(()=>{l=!0,w()},e)})),h.push(new Promise((w,L)=>{let y={numThreads:r};if(c)y.wasmBinary=c;else if(f||s)y.locateFile=m=>f??s+m;else if(i&&i.indexOf("blob:")!==0)y.locateFile=m=>new URL(m,i).href;else if(d){let m=We();m&&(y.locateFile=A=>m+A)}p(y).then(m=>{ke=!1,mt=!0,lt=m,w(),d&&URL.revokeObjectURL(d)},m=>{ke=!1,mr=!0,L(m)})})),await Promise.race(h),l)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},S=()=>{if(mt&&lt)return lt;throw new Error("WebAssembly is not initialized yet.")}});var F,Te,E,Ge=T(()=>{"use strict";ee();F=(t,e)=>{let r=S(),o=r.lengthBytesUTF8(t)+1,n=r._malloc(o);return r.stringToUTF8(t,n,o),e.push(n),n},Te=(t,e,r,o)=>{if(typeof t=="object"&&t!==null){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach(([n,s])=>{let a=e?e+n:n;if(typeof s=="object")Te(s,a+".",r,o);else if(typeof s=="string"||typeof s=="number")o(a,s.toString());else if(typeof s=="boolean")o(a,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},E=t=>{let e=S(),r=e.stackSave();try{let o=e.PTR_SIZE,n=e.stackAlloc(2*o);e._OrtGetLastError(n,n+o);let s=Number(e.getValue(n,o===4?"i32":"i64")),a=e.getValue(n+o,"*"),i=a?e.UTF8ToString(a):"";throw new Error(`${t} ERROR_CODE: ${s}, ERROR_MESSAGE: ${i}`)}finally{e.stackRestore(r)}}});var hr,yr=T(()=>{"use strict";ee();Ge();hr=t=>{let e=S(),r=0,o=[],n=t||{};try{if(t?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(n.terminate=!1);let s=0;return t?.tag!==void 0&&(s=F(t.tag,o)),r=e._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&E("Can't create run options."),t?.extra!==void 0&&Te(t.extra,"",new WeakSet,(a,i)=>{let u=F(a,o),f=F(i,o);e._OrtAddRunConfigEntry(r,u,f)!==0&&E(`Can't set a run config entry: ${a} - ${i}.`)}),[r,o]}catch(s){throw r!==0&&e._OrtReleaseRunOptions(r),o.forEach(a=>e._free(a)),s}}});var fn,cn,dn,ht,ue,pn,br,wr=T(()=>{"use strict";ee();Ge();fn=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},cn=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},dn=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(t.enableMemPattern=!1)},ht=(t,e,r,o)=>{let n=F(e,o),s=F(r,o);S()._OrtAddSessionConfigEntry(t,n,s)!==0&&E(`Can't set a session config entry: ${e} - ${r}.`)},ue=(t,e,r,o)=>{let n=F(e,o),s=F(r,o);t.push([n,s])},pn=async(t,e,r)=>{let o=e.executionProviders;for(let n of o){let s=typeof n=="string"?n:n.name,a=[];switch(s){case"webnn":if(s="WEBNN",typeof n!="string"){let p=n?.deviceType;p&&ht(t,"deviceType",p,r)}break;case"webgpu":{s="WebGPU";let d;if(typeof n!="string"){let l=n;if(l.device)if(typeof GPUDevice<"u"&&l.device instanceof GPUDevice)d=l.device;else throw new Error("Invalid GPU device set in WebGPU EP options.");let{enableGraphCapture:h}=e;if(typeof h=="boolean"&&h&&ue(a,"enableGraphCapture","1",r),typeof l.preferredLayout=="string"&&ue(a,"preferredLayout",l.preferredLayout,r),l.forceCpuNodeNames){let w=Array.isArray(l.forceCpuNodeNames)?l.forceCpuNodeNames:[l.forceCpuNodeNames];ue(a,"forceCpuNodeNames",w.join(`
`),r)}l.validationMode&&ue(a,"validationMode",l.validationMode,r)}let p=S().webgpuRegisterDevice(d);if(p){let[l,h,w]=p;ue(a,"deviceId",l.toString(),r),ue(a,"webgpuInstance",h.toString(),r),ue(a,"webgpuDevice",w.toString(),r)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${s}`)}let i=F(s,r),u=a.length,f=0,c=0;if(u>0){f=S()._malloc(u*S().PTR_SIZE),r.push(f),c=S()._malloc(u*S().PTR_SIZE),r.push(c);for(let d=0;d<u;d++)S().setValue(f+d*S().PTR_SIZE,a[d][0],"*"),S().setValue(c+d*S().PTR_SIZE,a[d][1],"*")}await S()._OrtAppendExecutionProvider(t,i,f,c,u)!==0&&E(`Can't append execution provider: ${s}.`)}},br=async t=>{let e=S(),r=0,o=[],n=t||{};dn(n);try{let s=fn(n.graphOptimizationLevel??"all"),a=cn(n.executionMode??"sequential"),i=typeof n.logId=="string"?F(n.logId,o):0,u=n.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log severity level is not valid: ${u}`);let f=n.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let c=typeof n.optimizedModelFilePath=="string"?F(n.optimizedModelFilePath,o):0;if(r=e._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,a,!!n.enableProfiling,0,i,u,f,c),r===0&&E("Can't create session options."),n.executionProviders&&await pn(r,n,o),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);ht(r,"enableGraphCapture",n.enableGraphCapture.toString(),o)}if(n.freeDimensionOverrides)for(let[d,p]of Object.entries(n.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof p!="number"||!Number.isInteger(p)||p<0)throw new Error(`free dimension override value must be a non-negative integer: ${p}`);let l=F(d,o);e._OrtAddFreeDimensionOverride(r,l,p)!==0&&E(`Can't set a free dimension override: ${d} - ${p}.`)}return n.extra!==void 0&&Te(n.extra,"",new WeakSet,(d,p)=>{ht(r,d,p,o)}),[r,o]}catch(s){throw r!==0&&e._OrtReleaseSessionOptions(r)!==0&&E("Can't release session options."),o.forEach(a=>e._free(a)),s}}});var te,$e,le,fe,Ee,ze,Ve,yt,ce=T(()=>{"use strict";te=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},$e=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},le=(t,e)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof e=="number"?e:e.reduce((n,s)=>n*s,1);return r>0?Math.ceil(o*r):void 0},fe=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},Ee=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},ze=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",Ve=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",yt=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}});var Se,bt=T(()=>{"use strict";Be();Se=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=nt("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:r}=nt("node:fs"),o=r(t),n=[];for await(let s of o)n.push(s);return new Uint8Array(Buffer.concat(n))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let r=e.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let n=e.body.getReader(),s;try{s=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let u=Math.ceil(o/65536);s=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let a=0;for(;;){let{done:i,value:u}=await n.read();if(i)break;let f=u.byteLength;new Uint8Array(s,a,f).set(u),a+=f}return new Uint8Array(s,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var gr,Tr=T(()=>{"use strict";ce();gr=(t,e)=>new(fe(e))(t)});var ln,mn,Er,Sr,Ir,hn,R,wt=T(()=>{"use strict";ce();ln=["V","I","W","E","F"],mn=(t,e)=>{console.log(`[${ln[t]},${new Date().toISOString()}]${e}`)},Ir=(t,e)=>{Er=t,Sr=e},hn=(t,e)=>{let r=Ee(t),o=Ee(Er);r>=o&&mn(r,typeof e=="function"?e():e)},R=(...t)=>{Sr&&hn(...t)}});var Ar,Tt,vr,yn,Lr,bn,Mr,je,He,gt,xr,Br=T(()=>{"use strict";ce();wt();Ar=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Tt=(t,e)=>{if(e==="int32")return t;let r=Ar.get(e);if(!r)throw new Error(`WebNN backend does not support data type: ${e}`);let o=r/8;if(t.byteLength%o!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${o}.`);let n=t.byteLength/o,s=new(fe(e))(t.buffer,t.byteOffset,n);switch(e){case"int64":case"uint64":{let a=new Int32Array(n);for(let i=0;i<n;i++){let u=s[i];if(u>2147483647n||u<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");a[i]=Number(u)}return new Uint8Array(a.buffer)}case"int8":case"uint8":case"uint32":{if(e==="uint32"&&s.some(i=>i>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let a=Int32Array.from(s,Number);return new Uint8Array(a.buffer)}default:throw new Error(`Unsupported data conversion from ${e} to 'int32'`)}},vr=(t,e)=>{if(e==="int32")return t;if(t.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let r=t.byteLength/4,o=new Int32Array(t.buffer,t.byteOffset,r);switch(e){case"int64":{let n=BigInt64Array.from(o,BigInt);return new Uint8Array(n.buffer)}case"uint64":{if(o.some(s=>s<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let n=BigUint64Array.from(o,BigInt);return new Uint8Array(n.buffer)}case"int8":{if(o.some(s=>s<-128||s>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let n=Int8Array.from(o,Number);return new Uint8Array(n.buffer)}case"uint8":{if(o.some(n=>n<0||n>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(o,Number)}case"uint32":{if(o.some(s=>s<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let n=Uint32Array.from(o,Number);return new Uint8Array(n.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${e}`)}},yn=1,Lr=()=>yn++,bn=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),Mr=(t,e)=>{let r=Ar.get(t);if(!r)throw new Error(`WebNN backend does not support data type: ${t}`);return e.length>0?Math.ceil(e.reduce((o,n)=>o*n)*r/8):0},je=class{constructor(e){this.isDataConverted=!1;let{sessionId:r,context:o,tensor:n,dataType:s,shape:a,fallbackDataType:i}=e;this.sessionId=r,this.mlContext=o,this.mlTensor=n,this.dataType=s,this.tensorShape=a,this.fallbackDataType=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return Mr(this.dataType,this.tensorShape)}destroy(){R("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(this.fallbackDataType){let r=await this.mlContext.readTensor(this.mlTensor),o=vr(new Uint8Array(r),this.dataType);if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(o);return}else return o.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,r,o){return this.mlContext===e&&this.dataType===r&&this.tensorShape.length===o.length&&this.tensorShape.every((n,s)=>n===o[s])}setIsDataConverted(e){this.isDataConverted=e}},He=class{constructor(e,r){this.tensorManager=e;this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,r,o,n){let s=this.tensorManager.getMLContext(e),a=this.tensorManager.getMLOpSupportLimits(e),i;if(!a?.input.dataTypes.includes(r)){if(i=bn.get(r),!i||a?.input.dataTypes.includes(i))throw new Error(`WebNN backend does not support data type: ${r}`);R("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${r} to ${i}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(s,r,o))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==Mr(r,o))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let u=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,r,o,u,!0,!0,i),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let r=e;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")r=Tt(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(e.byteLength===this.wrapper.byteLength){this.wrapper.write(r);return}else R("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(r):this.activeUpload=new Uint8Array(r)}async download(e){if(this.activeUpload){let r=this.wrapper?.isDataConverted?vr(this.activeUpload,this.wrapper?.type):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(r):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(r);return}else return r.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},gt=class{constructor(e){this.backend=e;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(e){let r=this.backend.getMLContext(e);if(!r)throw new Error("MLContext not found for session.");return r}getMLOpSupportLimits(e){return this.backend.getMLOpSupportLimits(e)}reserveTensorId(){let e=Lr();return this.tensorTrackersById.set(e,new He(this)),e}releaseTensorId(e){let r=this.tensorTrackersById.get(e);r&&(this.tensorTrackersById.delete(e),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(e,r,o,n,s){R("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${r}, dataType: ${o}, shape: ${n}, copyOld: ${s}}`);let a=this.tensorTrackersById.get(r);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,o,n,s)}upload(e,r){let o=this.tensorTrackersById.get(e);if(!o)throw new Error("Tensor not found.");o.upload(r)}async download(e,r){R("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${r?.byteLength}}`);let o=this.tensorTrackersById.get(e);if(!o)throw new Error("Tensor not found.");return o.download(r)}releaseTensorsForSession(e){for(let r of this.freeTensors)r.sessionId===e&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==e)}registerTensor(e,r,o,n){let s=this.getMLContext(e),a=Lr(),i=new je({sessionId:e,context:s,tensor:r,dataType:o,shape:n});return this.tensorTrackersById.set(a,new He(this,i)),this.externalTensors.add(i),a}async getCachedTensor(e,r,o,n,s,a,i){let u=this.getMLContext(e);for(let[c,d]of this.freeTensors.entries())if(d.canReuseTensor(u,r,o)){R("verbose",()=>`[WebNN] Reusing tensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${o}`);let p=this.freeTensors.splice(c,1)[0];return p.sessionId=e,p}R("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${o}}`);let f=await u.createTensor({dataType:i??r,shape:o,dimensions:o,usage:n,writable:s,readable:a});return new je({sessionId:e,context:u,tensor:f,dataType:r,shape:o,fallbackDataType:i})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},xr=(...t)=>new gt(...t)});var Or={};Ae(Or,{WebNNBackend:()=>Et});var Je,wn,Et,Ur=T(()=>{"use strict";ce();ee();Tr();Br();wt();Je=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),wn=(t,e)=>{if(t===e)return!0;if(t===void 0||e===void 0)return!1;let r=Object.keys(t).sort(),o=Object.keys(e).sort();return r.length===o.length&&r.every((n,s)=>n===o[s]&&t[n]===e[n])},Et=class{constructor(e){this.tensorManager=xr(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.sessionGraphOutputs=new Map;this.temporaryGraphInputs=[];this.temporaryGraphOutputs=[];this.temporarySessionTensorIds=new Map;this.mlOpSupportLimitsBySessionId=new Map;Ir(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){R("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){R("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let r=this.temporarySessionTensorIds.get(e);if(r){for(let o of r)R("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${o}}`),this.tensorManager.releaseTensorId(o);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let o=this.mlContextCache.findIndex(n=>n.gpuDevice===e);if(o!==-1)return this.mlContextCache[o].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:n}),n}}else if(e===void 0){let o=this.mlContextCache.findIndex(n=>n.options===void 0&&n.gpuDevice===void 0);if(o!==-1)return this.mlContextCache[o].mlContext;{let n=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:n}),n}}let r=this.mlContextCache.findIndex(o=>wn(o.options,e));if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:o}),o}}registerMLContext(e,r){this.mlContextBySessionId.set(e,r);let o=this.sessionIdsByMLContext.get(r);o||(o=new Set,this.sessionIdsByMLContext.set(r,o)),o.add(e),this.mlOpSupportLimitsBySessionId.has(e)||this.mlOpSupportLimitsBySessionId.set(e,r.opSupportLimits()),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let r=this.mlContextBySessionId.get(e);if(!r)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e),this.mlOpSupportLimitsBySessionId.delete(e);let o=this.sessionIdsByMLContext.get(r);if(o.delete(e),o.size===0){this.sessionIdsByMLContext.delete(r);let n=this.mlContextCache.findIndex(s=>s.mlContext===r);n!==-1&&this.mlContextCache.splice(n,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}getMLOpSupportLimits(e){return this.mlOpSupportLimitsBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){R("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,r,o,n,s){let a=Je.get(o);if(!a)throw new Error(`Unsupported ONNX data type: ${o}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,r,a,n,s)}async createTemporaryTensor(e,r,o){R("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${r}, shape: ${o}}`);let n=Je.get(r);if(!n)throw new Error(`Unsupported ONNX data type: ${r}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,n,o,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,r){if(!S().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");R("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${r.byteLength}}`),this.tensorManager.upload(e,r)}async downloadTensor(e,r){return this.tensorManager.download(e,r)}createMLTensorDownloader(e,r){return async()=>{let o=await this.tensorManager.download(e);return gr(o,r)}}registerMLTensor(e,r,o,n){let s=Je.get(o);if(!s)throw new Error(`Unsupported ONNX data type: ${o}`);let a=this.tensorManager.registerTensor(e,r,s,n);return R("verbose",()=>`[WebNN] registerMLTensor {tensor: ${r}, dataType: ${s}, dimensions: ${n}} -> {tensorId: ${a}}`),a}registerMLConstant(e,r,o,n,s,a,i=!1){if(!a)throw new Error("External mounted files are not available.");let u=e;e.startsWith("./")&&(u=e.substring(2));let f=a.get(u);if(!f)throw new Error(`File with name ${u} not found in preloaded files.`);if(r+o>f.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let c=f.slice(r,r+o).buffer,d;switch(s.dataType){case"float32":d=new Float32Array(c);break;case"float16":d=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(c):new Uint16Array(c);break;case"int32":d=new Int32Array(c);break;case"uint32":d=new Uint32Array(c);break;case"int64":if(i){let p=Tt(new Uint8Array(c),"int64");d=new Int32Array(p.buffer),s.dataType="int32"}else d=new BigInt64Array(c);break;case"uint64":d=new BigUint64Array(c);break;case"int8":d=new Int8Array(c);break;case"int4":case"uint4":case"uint8":d=new Uint8Array(c);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return R("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),n.constant(s,d)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,r){let o=this.sessionGraphInputs.get(e);return o?o.includes(r):!1}isGraphOutput(e,r){let o=this.sessionGraphOutputs.get(e);return o?o.includes(r):!1}isGraphInputOutputTypeSupported(e,r,o=!0){let n=Je.get(te(r)),s=this.mlOpSupportLimitsBySessionId.get(e);return typeof n>"u"?!1:o?!!s?.input.dataTypes.includes(n):!!s?.output.dataTypes.includes(n)}flush(){}}});var gn,De,Ce,de,Tn,Dr,ge,Pe,_e,Cr,Re,Ne,Fe,dt=T(()=>{"use strict";Q();yr();wr();ce();ee();Ge();bt();gn=(t,e)=>{S()._OrtInit(t,e)!==0&&E("Can't initialize onnxruntime.")},De=async t=>{gn(t.wasm.numThreads,Ee(t.logLevel))},Ce=async(t,e)=>{S().asyncInit?.();let r=t.webgpu.adapter;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(r){if(typeof r.limits!="object"||typeof r.features!="object"||typeof r.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let o=t.webgpu.powerPreference;if(o!==void 0&&o!=="low-power"&&o!=="high-performance")throw new Error(`Invalid powerPreference setting: "${o}"`);let n=t.webgpu.forceFallbackAdapter;if(n!==void 0&&typeof n!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(r=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:n}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(e==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");if(e==="webgpu"&&S().webgpuInit(o=>{t.webgpu.device=o}),e==="webnn"){let o=new(Ur(),ot(Or)).WebNNBackend(t);S().webnnInit([o,()=>o.reserveTensorId(),n=>o.releaseTensorId(n),async(n,s,a,i,u)=>o.ensureTensor(n,s,a,i,u),(n,s)=>{o.uploadTensor(n,s)},async(n,s)=>o.downloadTensor(n,s),(n,s)=>o.registerMLContext(n,s),!!t.trace])}},de=new Map,Tn=t=>{let e=S(),r=e.stackSave();try{let o=e.PTR_SIZE,n=e.stackAlloc(2*o);e._OrtGetInputOutputCount(t,n,n+o)!==0&&E("Can't get session input/output count.");let a=o===4?"i32":"i64";return[Number(e.getValue(n,a)),Number(e.getValue(n+o,a))]}finally{e.stackRestore(r)}},Dr=(t,e)=>{let r=S(),o=r.stackSave(),n=0;try{let s=r.PTR_SIZE,a=r.stackAlloc(2*s);r._OrtGetInputOutputMetadata(t,e,a,a+s)!==0&&E("Can't get session input/output metadata.");let u=Number(r.getValue(a,"*"));n=Number(r.getValue(a+s,"*"));let f=r.HEAP32[n/4];if(f===0)return[u,0];let c=r.HEAPU32[n/4+1],d=[];for(let p=0;p<c;p++){let l=Number(r.getValue(n+8+p*s,"*"));d.push(l!==0?r.UTF8ToString(l):Number(r.getValue(n+8+(p+c)*s,"*")))}return[u,f,d]}finally{r.stackRestore(o),n!==0&&r._OrtFree(n)}},ge=t=>{let e=S(),r=e._malloc(t.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,r),[r,t.byteLength]},Pe=async(t,e)=>{let r,o,n=S();Array.isArray(t)?[r,o]=t:t.buffer===n.HEAPU8.buffer?[r,o]=[t.byteOffset,t.byteLength]:[r,o]=ge(t);let s=0,a=0,i=0,u=[],f=[],c=[];try{if([a,u]=await br(e),e?.externalData&&n.mountExternalData){let b=[];for(let I of e.externalData){let D=typeof I=="string"?I:I.path;b.push(Se(typeof I=="string"?I:I.data).then(k=>{n.mountExternalData(D,k)}))}await Promise.all(b)}for(let b of e?.executionProviders??[])if((typeof b=="string"?b:b.name)==="webnn"){if(n.shouldTransferToMLTensor=!1,typeof b!="string"){let D=b,k=D?.context,C=D?.gpuDevice,W=D?.deviceType,H=D?.powerPreference;k?n.currentContext=k:C?n.currentContext=await n.webnnCreateMLContext(C):n.currentContext=await n.webnnCreateMLContext({deviceType:W,powerPreference:H})}else n.currentContext=await n.webnnCreateMLContext();break}s=await n._OrtCreateSession(r,o,a),n.webgpuOnCreateSession?.(s),s===0&&E("Can't create a session."),n.jsepOnCreateSession?.(),n.currentContext&&(n.webnnRegisterMLContext(s,n.currentContext),n.currentContext=void 0,n.shouldTransferToMLTensor=!0);let[d,p]=Tn(s),l=!!e?.enableGraphCapture,h=[],w=[],L=[],y=[],m=[];for(let b=0;b<d;b++){let[I,D,k]=Dr(s,b);I===0&&E("Can't get an input name."),f.push(I);let C=n.UTF8ToString(I);h.push(C),L.push(D===0?{name:C,isTensor:!1}:{name:C,isTensor:!0,type:$e(D),shape:k})}for(let b=0;b<p;b++){let[I,D,k]=Dr(s,b+d);I===0&&E("Can't get an output name."),c.push(I);let C=n.UTF8ToString(I);w.push(C),y.push(D===0?{name:C,isTensor:!1}:{name:C,isTensor:!0,type:$e(D),shape:k});{if(l&&e?.preferredOutputLocation===void 0){m.push("gpu-buffer");continue}let W=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[C]??"cpu",H=n.webnnIsGraphOutput;if(W==="cpu"&&H&&H(s,C)){m.push("ml-tensor-cpu-output");continue}if(W!=="cpu"&&W!=="cpu-pinned"&&W!=="gpu-buffer"&&W!=="ml-tensor")throw new Error(`Not supported preferred output location: ${W}.`);if(l&&W!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${W}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);m.push(W)}}let A=null;return m.some(b=>b==="gpu-buffer"||b==="ml-tensor"||b==="ml-tensor-cpu-output")&&(i=n._OrtCreateBinding(s),i===0&&E("Can't create IO binding."),A={handle:i,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map(b=>b==="ml-tensor-cpu-output"?"ml-tensor":b).map(b=>yt(b))}),de.set(s,[s,f,c,A,l,!1]),[s,h,w,L,y]}catch(d){throw f.forEach(p=>n._OrtFree(p)),c.forEach(p=>n._OrtFree(p)),i!==0&&n._OrtReleaseBinding(i)!==0&&E("Can't release IO binding."),s!==0&&n._OrtReleaseSession(s)!==0&&E("Can't release session."),d}finally{n._free(r),a!==0&&n._OrtReleaseSessionOptions(a)!==0&&E("Can't release session options."),u.forEach(d=>n._free(d)),n.unmountExternalData?.()}},_e=t=>{let e=S(),r=de.get(t);if(!r)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,n,s,a,i]=r;a&&(i&&e._OrtClearBoundOutputs(a.handle)!==0&&E("Can't clear bound outputs."),e._OrtReleaseBinding(a.handle)!==0&&E("Can't release IO binding.")),e.jsepOnReleaseSession?.(t),e.webnnOnReleaseSession?.(t),e.webgpuOnReleaseSession?.(t),n.forEach(u=>e._OrtFree(u)),s.forEach(u=>e._OrtFree(u)),e._OrtReleaseSession(o)!==0&&E("Can't release session."),de.delete(t)},Cr=async(t,e,r,o,n,s,a=!1)=>{if(!t){e.push(0);return}let i=S(),u=i.PTR_SIZE,f=t[0],c=t[1],d=t[3],p=d,l,h;if(f==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let y=t[2].gpuBuffer;h=le(te(f),c);{let m=i.webgpuRegisterBuffer;if(!m)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=m(y,o)}}else if(d==="ml-tensor"){let y=t[2].mlTensor;h=le(te(f),c);let m=i.webnnRegisterMLTensor;if(!m)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');l=m(o,y,te(f),c)}else{let y=t[2];if(Array.isArray(y)){h=u*y.length,l=i._malloc(h),r.push(l);for(let m=0;m<y.length;m++){if(typeof y[m]!="string")throw new TypeError(`tensor data at index ${m} is not a string`);i.setValue(l+m*u,F(y[m],r),"*")}}else{let m=i.webnnIsGraphInput,A=i.webnnIsGraphOutput;if(f!=="string"&&m&&A){let b=i.UTF8ToString(n);if(m(o,b)||A(o,b)){let I=te(f);h=le(I,c),p="ml-tensor";let D=i.webnnCreateTemporaryTensor,k=i.webnnUploadTensor;if(!D||!k)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let C=await D(o,I,c);k(C,new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),l=C}else h=y.byteLength,l=i._malloc(h),r.push(l),i.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,h),l)}else h=y.byteLength,l=i._malloc(h),r.push(l),i.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,h),l)}}let w=i.stackSave(),L=i.stackAlloc(4*c.length);try{c.forEach((m,A)=>i.setValue(L+A*u,m,u===4?"i32":"i64"));let y=i._OrtCreateTensor(te(f),l,h,L,c.length,yt(p));y===0&&E(`Can't create tensor for input/output. session=${o}, index=${s}.`),e.push(y)}finally{i.stackRestore(w)}},Re=async(t,e,r,o,n,s)=>{let a=S(),i=a.PTR_SIZE,u=de.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let f=u[0],c=u[1],d=u[2],p=u[3],l=u[4],h=u[5],w=e.length,L=o.length,y=0,m=[],A=[],b=[],I=[],D=[],k=a.stackSave(),C=a.stackAlloc(w*i),W=a.stackAlloc(w*i),H=a.stackAlloc(L*i),At=a.stackAlloc(L*i);try{[y,m]=hr(s),Z("wasm prepareInputOutputTensor");for(let g=0;g<w;g++)await Cr(r[g],A,I,t,c[e[g]],e[g],l);for(let g=0;g<L;g++)await Cr(n[g],b,I,t,d[o[g]],w+o[g],l);K("wasm prepareInputOutputTensor");for(let g=0;g<w;g++)a.setValue(C+g*i,A[g],"*"),a.setValue(W+g*i,c[e[g]],"*");for(let g=0;g<L;g++)a.setValue(H+g*i,b[g],"*"),a.setValue(At+g*i,d[o[g]],"*");if(p&&!h){let{handle:g,outputPreferredLocations:$,outputPreferredLocationsEncoded:Qe}=p;if(c.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${c.length}).`);Z("wasm bindInputsOutputs");for(let M=0;M<w;M++){let j=e[M];await a._OrtBindInput(g,c[j],A[M])!==0&&E(`Can't bind input[${M}] for session=${t}.`)}for(let M=0;M<L;M++){let j=o[M];n[M]?.[3]?(D.push(b[M]),a._OrtBindOutput(g,d[j],b[M],0)!==0&&E(`Can't bind pre-allocated output[${M}] for session=${t}.`)):a._OrtBindOutput(g,d[j],0,Qe[j])!==0&&E(`Can't bind output[${M}] to ${$[M]} for session=${t}.`)}K("wasm bindInputsOutputs"),de.set(t,[f,c,d,p,l,!0])}a.jsepOnRunStart?.(f),a.webnnOnRunStart?.(f);let O;p?O=await a._OrtRunWithBinding(f,p.handle,L,H,y):O=await a._OrtRun(f,W,C,w,At,L,H,y),O!==0&&E("failed to call OrtRun().");let J=[],vt=[];Z("wasm ProcessOutputTensor");for(let g=0;g<L;g++){let $=Number(a.getValue(H+g*i,"*"));if($===b[g]||D.includes(b[g])){J.push(n[g]),$!==b[g]&&a._OrtReleaseTensor($)!==0&&E("Can't release tensor.");continue}let Qe=a.stackSave(),M=a.stackAlloc(4*i),j=!1,B,N=0;try{a._OrtGetTensorData($,M,M+i,M+2*i,M+3*i)!==0&&E(`Can't access output tensor data on index ${g}.`);let et=i===4?"i32":"i64",Le=Number(a.getValue(M,et));N=a.getValue(M+i,"*");let Mt=a.getValue(M+i*2,"*"),Hr=Number(a.getValue(M+i*3,et)),Y=[];for(let P=0;P<Hr;P++)Y.push(Number(a.getValue(Mt+P*i,et)));a._OrtFree(Mt)!==0&&E("Can't free memory for tensor dims.");let q=Y.reduce((P,x)=>P*x,1);B=$e(Le);let ye=p?.outputPreferredLocations[o[g]];if(B==="string"){if(ye==="gpu-buffer"||ye==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let P=[];for(let x=0;x<q;x++){let X=a.getValue(N+x*i,"*"),be=a.getValue(N+(x+1)*i,"*"),tt=x===q-1?void 0:be-X;P.push(a.UTF8ToString(X,tt))}J.push([B,Y,P,"cpu"])}else if(ye==="gpu-buffer"&&q>0){let P=a.webgpuGetBuffer;if(!P)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let x=P(N),X=le(Le,q);if(X===void 0||!ze(B))throw new Error(`Unsupported data type: ${B}`);j=!0;{a.webgpuRegisterBuffer(x,t,N);let be=a.webgpuCreateDownloader(x,X,t);J.push([B,Y,{gpuBuffer:x,download:async()=>{let tt=await be();return new(fe(B))(tt)},dispose:()=>{a._OrtReleaseTensor($)!==0&&E("Can't release tensor.")}},"gpu-buffer"])}}else if(ye==="ml-tensor"&&q>0){let P=a.webnnEnsureTensor,x=a.webnnIsGraphInputOutputTypeSupported;if(!P||!x)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(le(Le,q)===void 0||!Ve(B))throw new Error(`Unsupported data type: ${B}`);if(!x(t,B,!1))throw new Error(`preferredLocation "ml-tensor" for ${B} output is not supported by current WebNN Context.`);let be=await P(t,N,Le,Y,!1);j=!0,J.push([B,Y,{mlTensor:be,download:a.webnnCreateMLTensorDownloader(N,B),dispose:()=>{a.webnnReleaseTensorId(N),a._OrtReleaseTensor($)}},"ml-tensor"])}else if(ye==="ml-tensor-cpu-output"&&q>0){let P=a.webnnCreateMLTensorDownloader(N,B)(),x=J.length;j=!0,vt.push((async()=>{let X=[x,await P];return a.webnnReleaseTensorId(N),a._OrtReleaseTensor($),X})()),J.push([B,Y,[],"cpu"])}else{let P=fe(B),x=new P(q);new Uint8Array(x.buffer,x.byteOffset,x.byteLength).set(a.HEAPU8.subarray(N,N+x.byteLength)),J.push([B,Y,x,"cpu"])}}finally{a.stackRestore(Qe),B==="string"&&N&&a._free(N),j||a._OrtReleaseTensor($)}}p&&!l&&(a._OrtClearBoundOutputs(p.handle)!==0&&E("Can't clear bound outputs."),de.set(t,[f,c,d,p,l,!1]));for(let[g,$]of await Promise.all(vt))J[g][2]=$;return K("wasm ProcessOutputTensor"),J}finally{a.webnnOnRunEnd?.(f),a.stackRestore(k),r.forEach(O=>{O&&O[3]==="gpu-buffer"&&a.webgpuUnregisterBuffer(O[2].gpuBuffer)}),n.forEach(O=>{O&&O[3]==="gpu-buffer"&&a.webgpuUnregisterBuffer(O[2].gpuBuffer)}),A.forEach(O=>a._OrtReleaseTensor(O)),b.forEach(O=>a._OrtReleaseTensor(O)),I.forEach(O=>a._free(O)),y!==0&&a._OrtReleaseRunOptions(y),m.forEach(O=>a._free(O))}},Ne=t=>{let e=S(),r=de.get(t);if(!r)throw new Error("invalid session id");let o=r[0],n=e._OrtEndProfiling(o);n===0&&E("Can't get an profile file name."),e._OrtFree(n)},Fe=t=>{let e=[];for(let r of t){let o=r[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var pe,z,Ie,qe,Xe,Ye,St,It,me,he,Sn,Pr,_r,Rr,Nr,Fr,Wr,kr,Lt=T(()=>{"use strict";Q();dt();ee();Oe();pe=()=>!!v.wasm.proxy&&typeof document<"u",Ie=!1,qe=!1,Xe=!1,It=new Map,me=(t,e)=>{let r=It.get(t);r?r.push(e):It.set(t,[e])},he=()=>{if(Ie||!qe||Xe||!z)throw new Error("worker not ready")},Sn=t=>{switch(t.data.type){case"init-wasm":Ie=!1,t.data.err?(Xe=!0,St[1](t.data.err)):(qe=!0,St[0]()),Ye&&(URL.revokeObjectURL(Ye),Ye=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=It.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},Pr=async()=>{if(!qe){if(Ie)throw new Error("multiple calls to 'initWasm()' detected.");if(Xe)throw new Error("previous call to 'initWasm()' failed.");if(Ie=!0,pe())return new Promise((t,e)=>{z?.terminate(),pr().then(([r,o])=>{try{z=o,z.onerror=s=>e(s),z.onmessage=Sn,St=[t,e];let n={type:"init-wasm",in:v};if(!n.in.wasm.wasmPaths&&r){let s=We();s&&(n.in.wasm.wasmPaths=s)}z.postMessage(n),Ye=r}catch(n){e(n)}},e)});try{await Ue(v.wasm),await De(v),qe=!0}catch(t){throw Xe=!0,t}finally{Ie=!1}}},_r=async t=>{if(pe())return he(),new Promise((e,r)=>{me("init-ep",[e,r]);let o={type:"init-ep",in:{epName:t,env:v}};z.postMessage(o)});await Ce(v,t)},Rr=async t=>pe()?(he(),new Promise((e,r)=>{me("copy-from",[e,r]);let o={type:"copy-from",in:{buffer:t}};z.postMessage(o,[t.buffer])})):ge(t),Nr=async(t,e)=>{if(pe()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return he(),new Promise((r,o)=>{me("create",[r,o]);let n={type:"create",in:{model:t,options:{...e}}},s=[];t instanceof Uint8Array&&s.push(t.buffer),z.postMessage(n,s)})}else return Pe(t,e)},Fr=async t=>{if(pe())return he(),new Promise((e,r)=>{me("release",[e,r]);let o={type:"release",in:t};z.postMessage(o)});_e(t)},Wr=async(t,e,r,o,n,s)=>{if(pe()){if(r.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return he(),new Promise((a,i)=>{me("run",[a,i]);let u=r,f={type:"run",in:{sessionId:t,inputIndices:e,inputs:u,outputIndices:o,options:s}};z.postMessage(f,Fe(u))})}else return Re(t,e,r,o,n,s)},kr=async t=>{if(pe())return he(),new Promise((e,r)=>{me("end-profiling",[e,r]);let o={type:"end-profiling",in:t};z.postMessage(o)});Ne(t)}});var Gr,In,Ze,$r=T(()=>{"use strict";Q();Lt();ce();Be();bt();Gr=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},In=t=>{switch(t[3]){case"cpu":return new V(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!ze(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:n}=t[2];return V.fromGpuBuffer(r,{dataType:e,dims:t[1],download:o,dispose:n})}case"ml-tensor":{let e=t[0];if(!Ve(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:r,download:o,dispose:n}=t[2];return V.fromMLTensor(r,{dataType:e,dims:t[1],download:o,dispose:n})}default:throw new Error(`invalid data location: ${t[3]}`)}},Ze=class{async fetchModelAndCopyToWasmMemory(e){return Rr(await Se(e))}async loadModel(e,r){se();let o;typeof e=="string"?o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await Nr(o,r),ae()}async dispose(){return Fr(this.sessionId)}async run(e,r,o){se();let n=[],s=[];Object.entries(e).forEach(p=>{let l=p[0],h=p[1],w=this.inputNames.indexOf(l);if(w===-1)throw new Error(`invalid input '${l}'`);n.push(h),s.push(w)});let a=[],i=[];Object.entries(r).forEach(p=>{let l=p[0],h=p[1],w=this.outputNames.indexOf(l);if(w===-1)throw new Error(`invalid output '${l}'`);a.push(h),i.push(w)});let u=n.map((p,l)=>Gr(p,()=>`input "${this.inputNames[s[l]]}"`)),f=a.map((p,l)=>p?Gr(p,()=>`output "${this.outputNames[i[l]]}"`):null),c=await Wr(this.sessionId,s,u,i,f,o),d={};for(let p=0;p<c.length;p++)d[this.outputNames[i[p]]]=a[p]??In(c[p]);return ae(),d}startProfiling(){}endProfiling(){kr(this.sessionId)}}});var Vr={};Ae(Vr,{OnnxruntimeWebAssemblyBackend:()=>Ke,initializeFlags:()=>zr,wasmBackend:()=>Ln});var zr,Ke,Ln,jr=T(()=>{"use strict";Q();Lt();$r();zr=()=>{(typeof v.wasm.initTimeout!="number"||v.wasm.initTimeout<0)&&(v.wasm.initTimeout=0);let t=v.wasm.simd;if(typeof t!="boolean"&&t!==void 0&&t!=="fixed"&&t!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`),v.wasm.simd=!1),typeof v.wasm.proxy!="boolean"&&(v.wasm.proxy=!1),typeof v.wasm.trace!="boolean"&&(v.wasm.trace=!1),typeof v.wasm.numThreads!="number"||!Number.isInteger(v.wasm.numThreads)||v.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)v.wasm.numThreads=1;else{let e=typeof navigator>"u"?nt("node:os").cpus().length:navigator.hardwareConcurrency;v.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Ke=class{async init(e){zr(),await Pr(),await _r(e)}async createInferenceSessionHandler(e,r){let o=new Ze;return await o.loadModel(e,r),o}},Ln=new Ke});Q();Q();Q();var nr="1.25.0-dev.20260209-a3749f1353";var Ls=ct;{let t=(jr(),ot(Vr)).wasmBackend;ne("webgpu",t,5),ne("webnn",t,5),ne("cpu",t,10),ne("wasm",t,10)}Object.defineProperty(v.versions,"web",{value:nr,enumerable:!0});export{Kr as InferenceSession,qt as TRACE,Z as TRACE_EVENT_BEGIN,K as TRACE_EVENT_END,se as TRACE_FUNC_BEGIN,ae as TRACE_FUNC_END,V as Tensor,Ls as default,v as env,ne as registerBackend};
//# sourceMappingURL=ort.jspi.min.mjs.map
