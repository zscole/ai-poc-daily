"""
SafeExec: A Minimal Secure Python Sandbox for AI Agents

This module provides a lightweight, secure way to execute Python code
generated by LLMs without the complexity of containers or full sandboxing.

Key features:
- AST-based code validation (blocks imports, file ops, eval/exec)
- Controlled external function injection
- Execution state snapshots for pause/resume
- Async support for external function calls
- Resource limits (timeout, recursion depth)

Inspired by: Pydantic Monty, Anthropic's programmatic tool calling,
Cloudflare's Codemode, HuggingFace's smolagents

Author: Claw (OpenClaw AI)
Date: 2026-02-07
"""

import ast
import sys
import time
import json
import asyncio
import traceback
from typing import Any, Callable, Dict, List, Optional, Set
from dataclasses import dataclass, field
from contextlib import contextmanager
from functools import wraps

# -------------------------------------------------------------------
# Security: Blocked operations that LLM code should never access
# -------------------------------------------------------------------

BLOCKED_BUILTINS = {
    'eval', 'exec', 'compile', 'open', 'input',
    '__import__', 'globals', 'locals', 'vars',
    'getattr', 'setattr', 'delattr', 'hasattr',
    'breakpoint', 'exit', 'quit',
    'memoryview', 'type', 'object', 'classmethod',
    'staticmethod', 'property', 'super',
}

BLOCKED_NAMES = {
    '__builtins__', '__loader__', '__spec__',
    '__file__', '__cached__', '__doc__',
    '__class__', '__bases__', '__mro__',
    '__subclasses__', '__init_subclass__',
}

ALLOWED_BUILTINS = {
    'None', 'True', 'False',
    'abs', 'all', 'any', 'bin', 'bool', 'chr', 'dict',
    'divmod', 'enumerate', 'filter', 'float', 'format',
    'frozenset', 'hex', 'int', 'isinstance', 'issubclass',
    'iter', 'len', 'list', 'map', 'max', 'min', 'next',
    'oct', 'ord', 'pow', 'print', 'range', 'repr',
    'reversed', 'round', 'set', 'slice', 'sorted',
    'str', 'sum', 'tuple', 'zip',
    'Exception', 'ValueError', 'TypeError', 'KeyError',
    'IndexError', 'RuntimeError', 'StopIteration',
}


# -------------------------------------------------------------------
# AST Validator: Ensures code doesn't contain dangerous constructs
# -------------------------------------------------------------------

class SecurityViolation(Exception):
    """Raised when code contains blocked operations."""
    pass


class ASTValidator(ast.NodeVisitor):
    """
    Validates an AST tree to ensure it doesn't contain dangerous operations.
    
    Blocks:
    - Import statements
    - Dangerous builtins (eval, exec, open, etc.)
    - Attribute access to dunder methods
    - Class definitions (could escape sandbox)
    """
    
    def __init__(self, allowed_externals: Set[str]):
        self.allowed_externals = allowed_externals
        self.violations: List[str] = []
    
    def visit_Import(self, node: ast.Import) -> None:
        names = [alias.name for alias in node.names]
        self.violations.append(f"Import blocked: {', '.join(names)}")
    
    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        self.violations.append(f"Import blocked: from {node.module}")
    
    def visit_Name(self, node: ast.Name) -> None:
        name = node.id
        if name in BLOCKED_BUILTINS:
            self.violations.append(f"Blocked builtin: {name}")
        if name in BLOCKED_NAMES:
            self.violations.append(f"Blocked name: {name}")
        self.generic_visit(node)
    
    def visit_Attribute(self, node: ast.Attribute) -> None:
        if node.attr.startswith('__') and node.attr.endswith('__'):
            self.violations.append(f"Blocked dunder access: {node.attr}")
        if node.attr.startswith('_'):
            # Allow single underscore for private convention
            pass
        self.generic_visit(node)
    
    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        self.violations.append(f"Class definition blocked: {node.name}")
    
    def visit_Global(self, node: ast.Global) -> None:
        self.violations.append(f"Global statement blocked: {node.names}")
    
    def visit_Nonlocal(self, node: ast.Nonlocal) -> None:
        self.violations.append(f"Nonlocal statement blocked: {node.names}")
    
    def validate(self, tree: ast.AST) -> List[str]:
        """Validate the AST and return list of violations."""
        self.violations = []
        self.visit(tree)
        return self.violations


# -------------------------------------------------------------------
# Execution Context: Safe namespace for code execution
# -------------------------------------------------------------------

def create_safe_builtins() -> Dict[str, Any]:
    """Create a restricted builtins dict with only safe operations."""
    import builtins
    safe = {}
    for name in ALLOWED_BUILTINS:
        if hasattr(builtins, name):
            safe[name] = getattr(builtins, name)
    # Add None, True, False explicitly
    safe['None'] = None
    safe['True'] = True
    safe['False'] = False
    return safe


@dataclass
class ExecutionState:
    """Represents the state of an execution that can be serialized."""
    code: str
    inputs: Dict[str, Any]
    external_functions: List[str]
    pending_call: Optional[Dict[str, Any]] = None
    local_state: Dict[str, Any] = field(default_factory=dict)
    completed: bool = False
    result: Any = None
    error: Optional[str] = None
    
    def to_json(self) -> str:
        """Serialize state to JSON for storage/transmission."""
        return json.dumps({
            'code': self.code,
            'inputs': self.inputs,
            'external_functions': self.external_functions,
            'pending_call': self.pending_call,
            'completed': self.completed,
            'error': self.error,
            # Note: result and local_state may not be JSON-serializable
        }, default=str)
    
    @classmethod
    def from_json(cls, data: str) -> 'ExecutionState':
        """Deserialize state from JSON."""
        d = json.loads(data)
        return cls(**d)


# -------------------------------------------------------------------
# SafeExec: The main sandbox executor
# -------------------------------------------------------------------

class SafeExec:
    """
    A minimal secure Python sandbox for executing AI-generated code.
    
    Usage:
        executor = SafeExec(
            code='result = fetch(url) + process(data)',
            inputs={'url': 'https://api.example.com', 'data': [1, 2, 3]},
            external_functions={'fetch': my_fetch_fn, 'process': my_process_fn}
        )
        result = executor.run()
    
    Features:
        - Validates code before execution
        - Blocks dangerous operations
        - Injects controlled external functions
        - Supports timeout and resource limits
    """
    
    def __init__(
        self,
        code: str,
        inputs: Optional[Dict[str, Any]] = None,
        external_functions: Optional[Dict[str, Callable]] = None,
        timeout: float = 30.0,
        max_recursion: int = 100,
    ):
        self.code = code
        self.inputs = inputs or {}
        self.external_functions = external_functions or {}
        self.timeout = timeout
        self.max_recursion = max_recursion
        
        # Parse and validate immediately
        self._tree: Optional[ast.AST] = None
        self._validated = False
    
    def validate(self) -> List[str]:
        """
        Parse and validate the code.
        Returns list of security violations (empty if valid).
        """
        try:
            self._tree = ast.parse(self.code, mode='exec')
        except SyntaxError as e:
            return [f"Syntax error: {e}"]
        
        validator = ASTValidator(set(self.external_functions.keys()))
        violations = validator.validate(self._tree)
        
        if not violations:
            self._validated = True
        
        return violations
    
    def _create_namespace(self) -> Dict[str, Any]:
        """Create the execution namespace with safe builtins and injected functions."""
        namespace = {
            '__builtins__': create_safe_builtins(),
        }
        
        # Inject inputs
        namespace.update(self.inputs)
        
        # Inject external functions
        namespace.update(self.external_functions)
        
        return namespace
    
    def run(self) -> Any:
        """
        Execute the code and return the result.
        
        The result is the value of the last expression, or None if the
        code ends with a statement.
        """
        # Validate if not already done
        if not self._validated:
            violations = self.validate()
            if violations:
                raise SecurityViolation(
                    f"Code contains security violations:\n" +
                    "\n".join(f"  - {v}" for v in violations)
                )
        
        namespace = self._create_namespace()
        
        # Set resource limits
        old_recursion_limit = sys.getrecursionlimit()
        sys.setrecursionlimit(self.max_recursion)
        
        try:
            # Execute with timeout
            start = time.time()
            exec(compile(self._tree, '<sandbox>', 'exec'), namespace)
            
            if time.time() - start > self.timeout:
                raise TimeoutError(f"Execution exceeded {self.timeout}s timeout")
            
            # Return 'result' if defined, otherwise None
            return namespace.get('result')
            
        except SecurityViolation:
            raise
        except Exception as e:
            # Wrap execution errors
            raise RuntimeError(f"Execution error: {e}") from e
        finally:
            sys.setrecursionlimit(old_recursion_limit)
    
    async def run_async(self) -> Any:
        """
        Execute code that may call async external functions.
        
        External functions can be async, and the code can use 'await'.
        """
        if not self._validated:
            violations = self.validate()
            if violations:
                raise SecurityViolation(
                    f"Code contains security violations:\n" +
                    "\n".join(f"  - {v}" for v in violations)
                )
        
        namespace = self._create_namespace()
        
        # Add async primitives
        namespace['__builtins__']['asyncio'] = asyncio
        
        # Wrap code in async function
        wrapped_code = f"async def __async_main__():\n"
        for line in self.code.split('\n'):
            wrapped_code += f"    {line}\n"
        wrapped_code += "\n__async_result__ = asyncio.get_event_loop().run_until_complete(__async_main__())"
        
        try:
            tree = ast.parse(wrapped_code, mode='exec')
            exec(compile(tree, '<sandbox>', 'exec'), namespace)
            return namespace.get('result') or namespace.get('__async_result__')
        except Exception as e:
            raise RuntimeError(f"Async execution error: {e}") from e


# -------------------------------------------------------------------
# Interactive Executor: Step-by-step execution with pause/resume
# -------------------------------------------------------------------

class InteractiveExecutor:
    """
    An executor that pauses at external function calls.
    
    This enables:
    - Step-by-step execution
    - Human-in-the-loop approval of external calls
    - Serialization of execution state
    
    Usage:
        executor = InteractiveExecutor(
            code='data = fetch(url)\nresult = len(data)',
            inputs={'url': 'https://api.example.com'},
            external_functions=['fetch']
        )
        
        state = executor.start()
        while state.pending_call:
            # Perform the external call
            call_result = perform_external_call(state.pending_call)
            state = executor.resume(call_result)
        
        print(state.result)
    """
    
    def __init__(
        self,
        code: str,
        inputs: Optional[Dict[str, Any]] = None,
        external_functions: Optional[List[str]] = None,
    ):
        self.code = code
        self.inputs = inputs or {}
        self.external_names = set(external_functions or [])
        self._state: Optional[ExecutionState] = None
    
    def start(self) -> ExecutionState:
        """Start execution and return initial state."""
        self._state = ExecutionState(
            code=self.code,
            inputs=self.inputs.copy(),
            external_functions=list(self.external_names),
        )
        return self._execute_until_external()
    
    def resume(self, call_result: Any) -> ExecutionState:
        """Resume execution with the result of the pending external call."""
        if not self._state or not self._state.pending_call:
            raise RuntimeError("No pending call to resume")
        
        # Inject the call result
        var_name = self._state.pending_call.get('result_var')
        if var_name:
            self._state.local_state[var_name] = call_result
        
        self._state.pending_call = None
        return self._execute_until_external()
    
    def _execute_until_external(self) -> ExecutionState:
        """Execute code until we hit an external function call or completion."""
        # This is a simplified implementation
        # A full implementation would use AST transformation or a custom interpreter
        
        try:
            tree = ast.parse(self.code, mode='exec')
        except SyntaxError as e:
            self._state.error = str(e)
            self._state.completed = True
            return self._state
        
        # For simplicity, we execute synchronously and detect external calls
        # In a production system, you'd use AST transformation
        namespace = {
            '__builtins__': create_safe_builtins(),
        }
        namespace.update(self.inputs)
        namespace.update(self._state.local_state)
        
        # Create proxy functions that capture calls
        pending = []
        
        def make_proxy(name):
            def proxy(*args, **kwargs):
                pending.append({
                    'function': name,
                    'args': args,
                    'kwargs': kwargs,
                })
                # Return a placeholder
                return f"__PENDING_{name}__"
            return proxy
        
        for name in self.external_names:
            namespace[name] = make_proxy(name)
        
        try:
            exec(compile(tree, '<sandbox>', 'exec'), namespace)
            
            if pending:
                self._state.pending_call = pending[0]
            else:
                self._state.completed = True
                self._state.result = namespace.get('result')
                
        except Exception as e:
            self._state.error = str(e)
            self._state.completed = True
        
        return self._state


# -------------------------------------------------------------------
# Demo: Codemode pattern with simulated LLM
# -------------------------------------------------------------------

def demo_basic_execution():
    """Demonstrate basic secure code execution."""
    print("=== Basic Execution Demo ===\n")
    
    # Simple arithmetic
    code = """
x = 10
y = 20
result = x + y * 2
"""
    executor = SafeExec(code)
    print(f"Code: {code}")
    print(f"Result: {executor.run()}\n")
    
    # With inputs
    code = """
total = sum(numbers)
average = total / len(numbers)
result = {'total': total, 'average': average}
"""
    executor = SafeExec(code, inputs={'numbers': [1, 2, 3, 4, 5]})
    print(f"Code: {code}")
    print(f"Result: {executor.run()}\n")


def demo_external_functions():
    """Demonstrate controlled external function injection."""
    print("=== External Functions Demo ===\n")
    
    # Define external functions that the LLM code can call
    def fetch_data(url: str) -> dict:
        """Simulated API fetch."""
        return {'status': 'ok', 'url': url, 'items': [1, 2, 3]}
    
    def process_items(items: list) -> int:
        """Process a list of items."""
        return sum(items) * 2
    
    code = """
# LLM-generated code that uses external functions
response = fetch_data('https://api.example.com/data')
items = response['items']
result = process_items(items)
"""
    
    executor = SafeExec(
        code,
        external_functions={
            'fetch_data': fetch_data,
            'process_items': process_items,
        }
    )
    
    print(f"Code: {code}")
    print(f"Result: {executor.run()}\n")


def demo_security_validation():
    """Demonstrate security violation detection."""
    print("=== Security Validation Demo ===\n")
    
    dangerous_codes = [
        "import os",
        "from subprocess import call",
        "eval('1+1')",
        "open('/etc/passwd').read()",
        "__import__('os').system('ls')",
        "class Exploit: pass",
    ]
    
    for code in dangerous_codes:
        executor = SafeExec(code)
        violations = executor.validate()
        print(f"Code: {code}")
        print(f"Violations: {violations}\n")


def demo_codemode_pattern():
    """
    Demonstrate the 'codemode' pattern where LLM writes code
    instead of using traditional tool calling.
    """
    print("=== Codemode Pattern Demo ===\n")
    
    # Simulate an LLM generating code to accomplish a task
    # Instead of: {"tool": "search", "query": "weather in NYC"}
    # LLM writes: search("weather in NYC")
    
    llm_generated_code = """
# Task: Get weather for multiple cities and find the warmest
cities = ['NYC', 'LA', 'Chicago', 'Miami']
temperatures = {}

for city in cities:
    weather = get_weather(city)
    temperatures[city] = weather['temp']

warmest_city = max(temperatures, key=temperatures.get)
result = {
    'warmest': warmest_city,
    'temperature': temperatures[warmest_city],
    'all_temps': temperatures
}
"""
    
    # Define the tools available to the LLM
    def get_weather(city: str) -> dict:
        """Simulated weather API."""
        fake_temps = {
            'NYC': 45,
            'LA': 72,
            'Chicago': 38,
            'Miami': 81,
        }
        return {
            'city': city,
            'temp': fake_temps.get(city, 60),
            'unit': 'F'
        }
    
    executor = SafeExec(
        llm_generated_code,
        external_functions={'get_weather': get_weather}
    )
    
    print("LLM Task: Find the warmest city")
    print(f"\nGenerated Code:\n{llm_generated_code}")
    
    result = executor.run()
    print(f"Result: {result}\n")
    
    # Show how this is more powerful than tool calling:
    # - LLM can write loops, conditionals, data transformations
    # - Single execution instead of multiple tool calls
    # - LLM can optimize the approach (e.g., parallel fetches in async)


def demo_state_serialization():
    """Demonstrate execution state serialization for pause/resume."""
    print("=== State Serialization Demo ===\n")
    
    executor = InteractiveExecutor(
        code="data = fetch(url)\nresult = len(data)",
        inputs={'url': 'https://api.example.com'},
        external_functions=['fetch']
    )
    
    state = executor.start()
    print(f"Started execution")
    print(f"Pending call: {state.pending_call}")
    print(f"\nSerialized state:\n{state.to_json()}\n")
    
    # In a real system, you would:
    # 1. Serialize and store the state
    # 2. Perform the external call (possibly async or on another system)
    # 3. Load the state and resume


if __name__ == '__main__':
    print("=" * 60)
    print("SafeExec: Secure Python Sandbox for AI Agents")
    print("=" * 60)
    print()
    
    demo_basic_execution()
    demo_external_functions()
    demo_security_validation()
    demo_codemode_pattern()
    demo_state_serialization()
    
    print("=" * 60)
    print("All demos completed successfully!")
    print("=" * 60)
